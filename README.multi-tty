			-*- coding: utf-8; -*-
GOAL
----

The ultimate goal of this branch is to implement support for opening
multiple, different tty devices and simultaneous X and tty frames from
a single Emacs session.

WHO IS DOING IT
---------------

I'm Károly Lőrentey.  My address: lorentey@elte.hu.

Patches or suggestions are welcome!

Retrieving the latest version of the branch:

	tla register-archive lorentey@elte.hu--2004 http://lorentey.web.elte.hu/arch/2004/
	tla get lorentey@elte.hu--2004/emacs--multi-tty--0 <directory>

(I use tla 1.1.)


STATUS
------

Basic multi-tty support is there; there are some rough edges, but it
already seems to be usable.  Emacsclient has been extended to support
opening a new terminal frame.

To try it out, compile the multi-tty branch with the following
commands:

   	mkdir +build
	cd +build
	../configure --with-x-toolkit=no --without-x
	make bootstrap

then start up the emacs server (src/emacs, M-x server-start), and then
(from a shell prompt on another terminal) start emacsclient with

	lib-src/emacsclient -f /optional/file/names...

You'll hopefully have two fully working, independent frames on
separate terminals.  (This seems to be very useful, emacsclient starts
up even faster than vi!) :-) You can close the newly opened frame and
return to the shell without exiting Emacs by pressing C-x 5 0, i.e.,
delete-frame.  Creating new frames on the same tty with C-x 5 2
works exactly as before.  Suspending Emacs is disabled at the moment.
If you exit emacs, all terminals should be restored to their previous
states.

X, Mac, Windows and DOS support is broken, probably doesn't even
compile -- this will be solved later.

Only tested on my GNU/Linux box.


NEWS
----

For the NEWS file:

** Support for multiple terminal devices has been added.  You can
   specify a terminal device (`tty' parameter) and a terminal type
   (`tty-type' parameter) to `make-terminal-frame'. `tty' must be a
   terminal device created by the updated emacsclient, or there will
   be problems with terminal input and window resizes.  

   You can test for the presence of multiple terminal support by
   testing for the `multi-tty' feature.

** A make-frame-on-tty function has been added to make it easier to
   create frames on new terminals.

** New functions: frame-tty-name, frame-tty-type for accessing
   terminal parameters, and delete-tty for closing the terminal
   device.

** Emacsclient has been extended to support opening a new terminal
   frame.

CHANGELOG
---------

See arch logs.


DIARY OF CHANGES
----------------

(ex-TODO items with explanations.)

-- Introduce a new abstraction for terminal devices.  

   (Done, see struct tty_output.  The abstraction is not yet
   complete.)

-- Change the bootstrap procedure to initialize tty_list.

   (Done, but needs review.)

-- Change make-terminal-frame to support specifying another tty.

   (Done, new frame parameters: `tty' and `tty-type'.)

-- Implement support for reading from multiple terminals.

   (Done, read_avail_input tries to read from each terminal, until one
   succeeds.  MULTIKBOARD is not used.  Secondary terminals don't send
   SIGIO!)

   (Update: They do, now.)

-- other-frame should cycle through the frames on the `current'
   terminal only.  

   (Done, by trivially modifiying next_frame and prev_frame.)

-- Support different terminal sizes.
   
   (Done, no problem.)

-- Make sure terminal resizes are handled gracefully.  (Could be
   problematic.)

   (Done.  We don't get automatic SIGWINCH for additional ttys,
   though.)

-- Extend emacsclient to automatically open a new tty when it connects
   to Emacs.
   
   (Done.  It's an ugly hack, needs more work.)

-- Redisplay must refresh the topmost frame on *all* terminals, not
   just the initial terminal.
   
   (Done, but introduced an ugly redisplay problems.  Ugh.)

-- Fix redisplay problems.

   (Done; it turned out that the entire Wcm structure must be moved
   inside tty_output.  Why didn't I catch this earlier?)

-- Provide a way for emacsclient to tell Emacs that the tty has been
   resized.

   (Done, simply forward the SIGWINCH signal.)

-- Each keypress should automatically select the frame corresponding
   to the terminal that it was coming from.  This means that Emacs
   must know from which terminal the last keyboard event came from.

   (Done, it was quite simple, the input event system already
   supported multiple frames.)

-- Fix SIGIO issue with secondary terminals.

   (Done, emacsclient signals Emacs after writing to the proxy pseudo
   terminal.  Note that this means that multi-tty does not work with
   raw ttys!)

   (Update: This is bullshit.  There is a read_input_waiting function,
   extend that somehow.)

   (Update of update: The first update was not right either, extending
   read_input_waiting was not necessary.  Secondary ttys do seem to
   send signals on input.)

-- Make make-terminal-frame look up the `tty' and `tty-type' frame
   parameters from the currently selected terminal before the global
   default.

   (Done.)

-- Put all cached terminal escape sequences into struct tty_output.
   Currently, they are still stored in global variables, so we don't
   really support multiple terminal types.

   (Done.  It was not fun.)

-- Implement sane error handling after initialization.  (Currently
   emacs exits if you specify a bad terminal type.)  The helpful error
   messages must still be provided when Emacs starts.

   (Done.)

-- Implement terminal deletion, i.e., deleting local frames, closing
   the tty device and restoring its previous state without exiting
   Emacs.

   (Done, but at the moment only called when an error happens during
   initialization.  There is a memory corruption error around this
   somewhere.)

-- Implement automatic deletion of terminals when the last frame on
   that terminal is closed.

   (Done.)

-- Restore tty screen after closing the terminal.

   (Done, we do the same as Emacs 21.2 for all terminals.)

-- 'TERM=dumb src/emacs' does not restore the terminal state.
   
   (Done.)

-- C-g should work on secondary terminals.

   (Done, but the binding is not configurable.)

-- Deal with SIGHUP in Emacs and in emacsclient.  (After this, the
   server-frames may be removed from server.el.)

   (Done, nothing to do.  It seems that Emacs does not receive SIGHUP
   from secondary ttys.)

-- Change emacsclient/server.el to support the -h argument better,
   i.e. automatically close the socket when the frame is closed.

   (Seems to be working OK.)

-- Fix mysterious memory corruption error with tty deletion.  To
   trigger it, try the following shell command:

	while true; do TERM=no-such-terminal-definition emacsclient -h; done

   Emacs usually dumps core after a few dozen iterations.  (The bug
   seems to be related to the xfree()ing or bzero()ing of
   tty_output.Wcm.  Maybe there are outside references to struct Wcm?
   Why were these vars collected into a struct before multi-tty
   support?)

   (Done.  Whew.  It turned out that the problem had nothing to do
   with hypothetical external references to Wcm, or any other
   tty_output component; it was simply that delete_tty closed the
   filehandles of secondary ttys twice, resulting in fclose doubly
   free()ing memory.  Utterly trivial matter.  I love the C's memory
   management, it puts hair on your chest.)

-- Support raw secondary terminals.  (Note that SIGIO works only on
   the controlling terminal.) Hint: extend read_input_waiting() for
   multiple ttys and hopefully this will be fixed.

   (Done, it seems to have been working already for some time.  It
   seems F_SETOWN does work, after all.  Not sure what made it fail
   earlier, but it seems to be fixed (there were several changes
   around request_sigio, maybe one of them did it).
   read_input_waiting() is only used in sys_select(), don't change
   it.)

-- Find out why does Emacs abort when it wants to close its
   controlling tty.  Hint: chan_process[] array.  Hey, maybe
   noninterrupt-IO would work, too?  Update: no, there is no process
   for stdin/out.

   (Done.  Added add/delete_keyboard_wait_descriptor to
   term_init/delete_tty.  The hint was right, in a way.)

-- Issue with SIGIO: it needs to be disabled during redisplay.  See if
   fcntl() kernel behaviour could be emulated by emacsclient.

   (Done.  Simply disabled the SIGIO emulation hack in emacsclient.)

-- server.el: There are issues with saving files in buffers of closed
   clients.  Try editing a file with emacsclient -f, and (without
   saving it) do a delete-frame.  The frame is closed without
   question, and a surprising confirmation prompt appears in another
   frame.

   (Done.  delete-frame now asks for confirmation if it still has
   pending buffers, and modified buffers don't seem to be deleted.)

-- emacsclient.el, server.el: Handle eval or file open errors when
   doing -f.

   (Done.)

-- Make parts of struct tty_output accessible from Lisp.  The device
   name and the type is sufficient.

   (Done, see frame-tty-name and frame-tty-type.)

-- Export delete_tty to the Lisp environment, for emacsclient.

   (Done, see delete-tty.)


THINGS TO DO
------------

** Find out the best way to support suspending Emacs with multiple
   ttys.  My guess: disable it on the controlling tty, but other ttys
   should pass it on to emacsclient somehow.  (It is (I hope) trivial
   to extend emacsclient to handle suspend/resume.  A `kill -STOP'
   almost works right now.)

** Move baud_rate to tty_output.

** Move device-specific parameters (like costs) commonly used by
   device backends to a common, device-dependent structure.

** Do tty output through term_hooks, like graphical display backends.

** Fix X support.

** Allow simultaneous X and tty frames.  (Handling input could be
   tricky.)

** Implement support for starting an interactive Emacs session without
   an initial frame.  (The user would connect to it and open frames
   later, with emacsclient.)  Not necessarily a good idea.

** Fix Mac support (I can't do this myself).

** Fix W32 support (I can't do this myself).

** Fix DOS support (I can't do this myself).

** Do a grep on XXX and ?? for more issues.

** Get rid of the accessor macros in termchar.h, or define macros for
   all members.

** Understand Emacs's low-level input system (it seems complicated) :-)
   and maybe rewrite multi-tty input in terms of MULTIKBOARD.

** What does interrupt_input do?  I tried to disable it for raw
   secondary tty support, but it does not seem to do anything useful.

** Make sure C-g goes to the right frame.  This is hard, as SIGINT
   doesn't have a tty parameter. :-(

** I have seen a case when Emacs with multiple ttys went ate 100% of
   CPU time.  Strace showed this loop:


	getpid()                                = 30284
	kill(30284, SIGIO)                      = 0
	--- SIGIO (I/O possible) @ 0 (0) ---
	ioctl(6, FIONREAD, [0])                 = -1 EIO (Input/output error)
	ioctl(5, FIONREAD, [0])                 = -1 EIO (Input/output error)
	ioctl(0, FIONREAD, [0])                 = 0
	sigreturn()                             = ? (mask now [])
	gettimeofday({1072842297, 747760}, NULL) = 0
	gettimeofday({1072842297, 747806}, NULL) = 0
	select(9, [0 3 5 6], NULL, NULL, {0, 0}) = 2 (in [5 6], left {0, 0})
	select(9, [0 3 5 6], NULL, NULL, {0, 0}) = 2 (in [5 6], left {0, 0})
	gettimeofday({1072842297, 748245}, NULL) = 0

   I have not been able to reproduce this.

;;; arch-tag: 8da1619e-2e79-41a8-9ac9-a0485daad17d
