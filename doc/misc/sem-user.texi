@c This file is included by semantic.texi

@c Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2009
@c Free Software Foundation, Inc.

@c Permission is granted to copy, distribute and/or modify this
@c document under the terms of the GNU Free Documentation License,
@c Version 1.3 or any later version published by the Free Software
@c Foundation; with no Invariant Sections, no Front-Cover Texts, and
@c no Back-Cover Texts.  A copy of the license is included in the
@c section entitled ``GNU Free Documentation License''.

You can begin using @semantic{} by enabling Semantic mode, a global
minor mode: type @kbd{M-x semantic-mode}, or click on the @samp{Source
Code Parsers (Semantic)} menu item in the @samp{Tools} menu.

When Semantic mode is turned on, Emacs automatically parses each file
you visit.  This allows you to use @semantic{} user commands in those
buffers.  It also enables a number of ``helper'' minor modes for
saving tags, displaying tag information, and so forth.  @xref{Semantic
mode}.

To enable Semantic mode each time you start Emacs, add the line
@code{(semantic-mode 1)} to your initialization file.  @xref{Init
File,,,emacs,Emacs manual}.

@menu
* Semantic mode::   Global minor mode for @semantic{}.
* SemanticDB::      Caching parsed buffers between sessions.
* Idle Scheduler::  Performing @semantic{} operations when idle.
@end menu

@node Semantic mode
@section Semantic mode
@cindex Semantic mode

Semantic mode is a global minor mode for @semantic{} as a whole.  When
enabled, each file you visit is automatically parsed, provided its
major mode is specified in the variable
@code{semantic-new-buffer-setup-functions} (the default is to parse
every buffer @semantic{} knows how to parse).

In each parser-enabled buffer, a number of @semantic{} commands are
available for navigating, querying, and editing source code.
@xref{Semantic mode user commands}.  Enabling Semantic mode also
installs a @samp{Development} menu on the menu-bar, with many of these
commands.

In addition, enabling Semantic mode turns on certain auxiliary global
minor modes, as specified by the variable
@code{semantic-default-submodes}.  The default auxiliary modes are
SemanticDB mode (@pxref{SemanticDB}) and Global Semantic Idle
Scheduler mode.  You can also toggle the auxiliary minor modes
separately, using their mode functions (e.g. @kbd{M-x
semanticdb-minor-mode}), or via the @samp{Development} menu.  These
auxiliary minor modes are described in the following sections.

@defvar semantic-new-buffer-setup-functions
The value of this variable is an alist of functions to call for
setting up @semantic{} parsing in the buffer.  Each element has the
form @code{(@var{mode} . @var{fn})}, where @var{mode} is a value of
@code{major-mode} for the buffer and @var{fn} is the corresponding
function for setting up the parser.  @var{fn} is called, with no
arguments, after the major mode is initialized (and after the mode
hooks have been run).

The default value enables @semantic{} for all supported major modes
(i.e., C, C++, Scheme, Javascript, Java, HTML, SRecode, and Make), but
you can remove modes from this list if you don't want to use
@semantic{} with them.
@end defvar

@defvar semantic-default-submodes
The value of this variable is a list of symbols, specifying the
auxiliary minor modes to enable when enabling Semantic mode.  The
valid mode symbols are:

@itemize
@item @code{semantic-idle-scheduler-mode} (@pxref{Idle Scheduler}).
@item @code{semanticdb-minor-mode} (@pxref{SemanticDB}).
@item @code{semantic-idle-summary-mode} (@pxref{Idle Summary Mode}).
@item @code{semantic-idle-completions-mode} (@pxref{Idle Completions Mode}).
@item @code{semantic-highlight-func-mode}
@item @code{semantic-decoration-mode}
@item @code{semantic-stickyfunc-mode}
@item @code{semantic-mru-bookmark-mode}
@end itemize
@end defvar

@menu
* Semantic mode user commands::
@end menu

@node Semantic mode user commands
@subsection Semantic mode user commands

Semantic mode provides a number of commands for navigating, querying,
and editing source code in a language-aware manner.  These commands
generally act on @dfn{tags}, which are the source-code units deemed
``important'' by the present programming language (e.g. functions in
the C programming language).

These commands may be used in any buffer that has been parsed by
@semantic{}.  Several of them prompt for a tag name using the
minibuffer; here, the @kbd{TAB} key can be used to complete tag names.
Others act on the @dfn{current tag}, meaning the tag at (or around)
point.

@table @kbd
@item \C-c , j
Prompt for a tag defined in the current file, and move point to it
(@code{semantic-complete-jump-local}).

@item \C-c , J
Prompt for a tag defined in any file that Emacs has parsed, and move
point to it (@code{semantic-complete-jump}).

@item \C-c , l
Display a list of the possible completions of the current tag
(@code{semantic-analyze-possible-completions}).

@item \C-c , g
Prompt for a tag, and display a list of tags that call it
(@code{semantic-symref-symbol}).

@item \C-c , G
Display a list of tags that call the current tag
(@code{semantic-symref}).

@item \C-c , p
Move point to the previous tag (@code{senator-previous-tag}).

@item \C-c , n
Move point to the next tag (@code{senator-next-tag}).

@item \C-c , u
Move point ``up'' one reference (@code{senator-go-to-up-reference}).
The meaning of ``up'' is language-dependent; in C++, for instance,
this means moving to the parent of the current tag.

@item \C-c, @key{SPC}
(@code{semantic-complete-analyze-inline})

@item \C-c,\C-w
Kill the current tag (@code{senator-kill-tag}).  This removes the text
for that tag, placing it in the kill ring.  You can retrieve the text
with @kbd{C-y}.  This also places the tag in the @dfn{tag ring}, so
that you can yank it with @kbd{\C-c,\C-y}, below.

@item \C-c,\M-w
Copy the current tag into the kill ring as well as the tag ring
(@code{senator-copy-tag}).

@item \C-c,\C-y
Yank a tag from the tag ring (@code{senator-yank-tag}).

@item \C-c,r
Copy the current tag into a register
(@code{senator-copy-tag-to-register}).  With an optional argument,
kill it as well.  This allows you to insert or jump to that tag with
the usual register commands.  @xref{Registers,,,emacs,Emacs manual}.

@item ?\C-c , @kbd{up}
Transpose the current tag with the previous one
(@code{senator-transpose-tags-up}).

@item ?\C-c ?, @kbd{down}
Transpose the current tag with the next one
(@code{senator-transpose-tags-down}).
@end table

@node SemanticDB
@section Semantic Database
@cindex SemanticDB

The Semantic Database (SemanticDB) caches the results of parsing
source code files.  This data can be saved to disk when you exit
Emacs, and reloaded automatically when you subsequently revisit the
same source code files.  This saves time by eliminating the need to
re-parse unmodified files.

SemanticDB also provides an @acronym{API} that programs can use to
acquire information about source code tags.  This information can be
accessed without loading the original the source files into memory.
It can also be used to create alternate ``back-ends'' for storing tag
information in alternative on-disk formats.

By default, SemanticDB is enabled together with Semantic mode.  To
disable it, remove it from @code{semantic-default-submodes}
(@pxref{Semantic mode}).  You can also enable or disable SemanticDB
with @kbd{M-x global-semanticdb-minor-mode}.

@deffn Command global-semanticdb-minor-mode
Toggle SemanticDB mode.  When enabled, any source code parsed by
@semantic{} is cached in a database.
@end deffn

SemanticDB offers a large number of customizable options, which are
described in the following subsections.

@menu
* Semanticdb Tag Storage::
* Semanticdb Search Configuration::
* Changing Backends::
* Create System Databases::
@end menu

@node Semanticdb Tag Storage
@subsection Semanticdb Tag Storage

Each time you exit Emacs, any data cached by SemanticDB is saved in
the directory @file{.emacs.d/semanticdb/}, located in your home
directory.  Within this directory, the cache data is written into a
set of files according to a SemanticDB-specific filename convention.
If the SemanticDB directory does not exist, Emacs first asks if you
want to create it.

You can change the name of the SemanticDB directory by customizing the
variable @code{semanticdb-default-save-directory}.

@anchor{semanticdb-default-save-directory}
@deffn Option semanticdb-default-save-directory
The name of the directory where SemanticDB cache files are saved.  If
the value is @code{nil}, SemanticDB saves its data into a single file,
in the current directory, whose filename is given by
@code{semanticdb-default-file-name}.
@end deffn

@anchor{semanticdb-default-file-name}
@deffn Option semanticdb-default-file-name
The name of a cache file in which to save SemanticDB, when
@code{semanticdb-default-save-directory} is @code{nil}.
@end deffn

You can force SemanticDB to save the data from only certain files, or
suppress saving altogether, by customizing
@code{semanticdb-persistent-path}:

@anchor{semanticdb-persistent-path}
@deffn Option semanticdb-persistent-path
List of valid paths for SemanticDB to cache.  Each element should be a
directory name (a string); then the parse data from any file in that
directory is saved.

As a special exception, the value of this variable can be a list
containing a single symbol: @code{never}, @code{always}, or
@code{project}.  The symbol @code{never} disables saving anywhere;
@code{always} enables saving everywhere; and @code{project} enables
saving directory based on the variable
@code{semanticdb-project-predicate-functions}.

The default value is @code{(always)}.
@end deffn

@anchor{semanticdb-project-predicate-functions}
@defvar semanticdb-project-predicate-functions
The value of this variable is a list of predicates for indicating that
a directory belongs to a project.  This list is used when the value of
@code{semanticdb-persistent-path} is @code{(project)}.  If the list is
empty, all paths are considered valid.

Project management packages, such as EDE (@pxref{Top,,,ede,EDE
manual}), may add their own predicates with @dfn{add-hook} to this
variable.  This allows SemanticDB to save tag caches in directories
controlled by them.
@end defvar

@anchor{semanticdb-save-database-hooks}
@deffn Option semanticdb-save-database-hooks
Abnormal hook run after a database is saved.  Each function is called
with one argument, the object representing the database recently
written.
@end deffn

@node Semanticdb Search Configuration
@subsection Semanticdb Search Configuration

  When another part of @semantic{} (or another Emacs package using
@semantic{}) queries the SemanticDB library for a source code tag, the
search need not be limited to tags defined within the current file.
It can include tags defined elsewhere, such as @dfn{header files}
referenced by the current file (e.g., via the C/C++ @code{#include}
directive).  While performing the search, the SemanticDB library may
even automatically visit other files and parse them, if necessary.

  The variable @code{semanticdb-find-default-throttle} determines how
aggressively SemanticDB searches for source code tags.  @xref{Search
Throttle}.

  The details of SemanticDB searches can vary from language to
language.  In C/C++ code, for example, SemanticDB distinguishes
between @dfn{project header files} and @dfn{system header files},
based on whether the @code{#include} directive uses the @code{""} or
@code{<>} filename delimiter.  SemanticDB looks for system header in
the @dfn{system include path} (@pxref{Include paths}).

@menu
* Search Throttle::     Controlling how semanticdb searches occur
* Semanticdb Roots::    Specifying the root of different projects
* Include paths::       Add/Remove directories to include search paths
* Semanticdb search debugging commands::
@end menu

@node Search Throttle
@subsubsection SemanticDB Search Throttle

The SemanticDB @dfn{search throttle} determines how aggressive
SemanticDB searches are.  It is controlled by the variable
@code{semanticdb-find-default-throttle}.  The default value of this
variable aims for maximum accuracy, at the expense of search time.

Other parts of the @semantic{} package, particularly the different
language parsers, may change the value of
@code{semanticdb-find-default-throttle}.  You can override its value,
for a given major mode, like this:

@example
(setq-mode-local c-mode
		 semanticdb-find-default-throttle
		 '(project unloaded system recursive))
@end example

@anchor{semanticdb-find-default-throttle}
@defvar semanticdb-find-default-throttle
The default throttle for @code{semanticdb-find} routines.
The throttle controls how detailed the list of database
tables is for a symbol lookup.  The value is a list with
the following keys:

@table @code
@item file
The file the search is being performed from.  This option is here for
completeness only, and is assumed to always be on.
@item local
Tables from the same local directory are included.  This includes
files directly referenced by a file name which might be in a different
directory.
@item project
Tables from the same local project are included If @code{project} is
specified, then @code{local} is assumed.
@item unloaded
If a table is not in memory, load it.  If it is not cached on disk
either, get the source, parse it, and create the table.
@item system
Tables from system databases.  These are specifically tables
from system header files, or language equivalent.
@item recursive
For include based searches, includes tables referenced by included
files.
@item omniscience
Included system databases which are omniscience, or somehow know
everything.  Omniscience databases are found in
@code{semanticdb-project-system-databases}.  The Emacs Lisp system
@var{db} is an omniscience database.
@end table
@end defvar

@node Semanticdb Roots
@subsubsection SemanticDB project roots

The @code{project} setting in the SemanticDB search throttle
(@pxref{Search Throttle}) tells SemanticDB to search within the
current single code project.  For @semantic{}'s point of view,
@dfn{projects} are determined by their top-level directories, or
@dfn{project roots}; every subdirectory of a project root is
considered part of the same project.

If you use EDE for project management, it will set the project roots
automatically.  @xref{Top,,,ede,EDE manual}.  You can also specify
them yourself.

@anchor{semanticdb-project-roots}
@deffn Option semanticdb-project-roots
The value of this variable is a list of directories (strings) that are
project roots.  All subdirectories of a project root are considered
part of the same project.  This variable can be overriden by
@code{semanticdb-project-root-functions}.
@end deffn

@anchor{semanticdb-project-root-functions}
@defvar semanticdb-project-root-functions
The value of this variable is a list of functions to determine a given
directory's project root.  These functions are called, one at a time,
with one argument (the directory name), and must return either
@code{nil}, a string (the project root), or a list of strings
(multiple project roots, for complex systems).  The first
non-@code{nil} return value, if any, is taken to be the project root,
overriding @code{semanticdb-project-roots}.
@end defvar

@node Include paths
@subsubsection Include Paths

System include paths are standard locations to find source code tags,
such as the @dfn{header files} in @file{/usr/include} and its
subdirectories on Unix-like operating systems.

You can add and remove system include paths using the following
commands:

@anchor{semantic-add-system-include}
@deffn Command semantic-add-system-include dir &optional mode
Prompts for a directory, @var{dir}, and add it as a system include
path for the current major mode.  When called non-interactively, the
major mode can be specified with the @var{mode} argument.
@end deffn

@anchor{semantic-remove-system-include}
@deffn Command semantic-remove-system-include dir &optional mode
Prompt for a directory, @var{dir}, and remove it from the system
include path for the current major mode (or @var{mode}).
@end deffn

@anchor{semantic-customize-system-include-path}
@deffn Command semantic-customize-system-include-path &optional mode
Customize the system include path for the current major mode (or
@var{mode}).
@end deffn

@anchor{semanticdb-implied-include-tags}
@defun semanticdb-implied-include-tags
Include tags implied for all files of a given mode.  You can set this
variable with @code{defvar-mode-local} for a particular mode so that
any symbols that exist for all files for that mode are included.
@end defun

@c @xref{Search Optimization}, for more information on include paths.

@node Semanticdb search debugging commands
@subsubsection Semanticdb search debugging commands

You can use @kbd{M-x semanticdb-dump-all-table-summary} to see the
list of databases that will be searched from a given buffer.  You can
follow up with @kbd{M-x semanticdb-find-test-translate-path} to then
make sure specific tables from the path are discovered correctly.

Alternately, you can get a list of include files @semantic{}
encountered, but could not find on disk using @kbd{M-x
semanticdb-find-adebug-lost-includes}.

@deffn Command semanticdb-dump-all-table-summary
@anchor{semanticdb-dump-all-table-summary}
Dump a list of all databases in Emacs memory.
@end deffn

@deffn Command semanticdb-find-test-translate-path &optional arg
@anchor{semanticdb-find-test-translate-path}
Call and output results of @dfn{semanticdb-find-translate-path}
With @var{arg} non-@code{nil}, specify a @var{brutish} translation.
@end deffn

@deffn Command semanticdb-find-adebug-lost-includes
@anchor{semanticdb-find-adebug-lost-includes}
Translate the current path, then display the lost includes.
Examines the variable @code{semanticdb-find-lost-includes}.
@end deffn

Lastly, you can test an explicit search term using this command:

@deffn Command semantic-adebug-searchdb regex
@anchor{semantic-adebug-searchdb}
Search the semanticdb for @var{regex} for the current buffer.
Display the results as a debug list.
@end deffn

@node Changing Backends
@subsection Changing Backends

If you want to use some other form of backend, you can use this
variable to choose which back end class to use for your general tag
storage.

The default is to save databases in flat files.  Alternatively, you
could write a new database backend that stores tags into a database,
or other storage system.

@anchor{semanticdb-new-database-class}
@defvar semanticdb-new-database-class
The default type of database created for new files.  This can be
changed on a per file basis, so that some directories are saved using
one mechanism, and some directories via a different mechanism.
@end defvar

@node Create System Databases
@subsection Create System Databases

If your supported language stores the system libraries in readily
available parsable source code, you can pre-generate database files
for them once, which will be used over and over for tools such as
summary-mode, or the analyzer.

@deffn Command semanticdb-create-ebrowse-database dir
@anchor{semanticdb-create-ebrowse-database}
Create an @var{ebrowse} database for directory @var{dir}.
The database file is stored in ~/.semanticdb, or whichever directory
is specified by @code{semanticdb-default-system-save-directory}.
@end deffn

@node Idle Scheduler
@section Idle Scheduler
@cindex Idle Scheduler

The @dfn{Semantic idle scheduler} is a part of @semantic{} that
performs various operations while Emacs is waiting for user input
(idle time).  Its primary job is to perform buffer parsing, but it is
also used for other purposes, such as displaying information about
tags.

@anchor{global-semantic-idle-scheduler-mode}
@deffn Command global-semantic-idle-scheduler-mode &optional arg
This command toggles Semantic Idle Scheduler mode in every
@semantic{}-enabled buffer.  This minor mode ensures that the buffer
is automatically reparsed whenever Emacs is idle.  If there is
additional idle time, it runs jobs scheduled by other parts of
@semantic{}, such as Semantic Idle Summary mode (@pxref{Idle Summary
Mode}) and Semantic Idle Completions mode (@pxref{Idle Completions
Mode}).
@end deffn

@anchor{semantic-idle-scheduler-idle-time}
@deffn Option semantic-idle-scheduler-idle-time
The value of this variable is the amount of idle time, in seconds,
before the Semantic idle scheduler activates.  The default is 1.
@end deffn

@anchor{semantic-idle-scheduler-verbose-flag}
@deffn Option semantic-idle-scheduler-verbose-flag
If this variable is non-@code{nil}, the idle scheduler prints verbose
messages while running, which are useful for debugging.
@end deffn

@menu
* Reparsing Options::          Reparsing the current buffer in idle time
* Idle Working Options::       Options for extra work done at idle time
* Debugging Idle Time Issues:: How to produce good bug reports
* Idle Summary Mode::          Display prototype of symbol under cursor
* Idle Completions Mode::      Smart completion pop-up help
@end menu

@node Reparsing Options
@subsection Reparsing Options

When activated during idle time, the Semantic idle scheduler
automatically reparses all buffers that need it.  Any arriving user
input cancels this, returning Emacs to its normal editing behavior.

@anchor{semantic-idle-scheduler-max-buffer-size}
@deffn Option semantic-idle-scheduler-max-buffer-size
Maximum size in bytes of buffers automatically reparsed.  If this
value is less than or equal to @var{0}, buffers are automatically
reparsed regardless of their size.
@end deffn

@anchor{semantic-idle-scheduler-no-working-message}
@deffn Option semantic-idle-scheduler-no-working-message
If non-@code{nil}, disable display of working messages whie reparsing.
@end deffn

@anchor{semantic-idle-scheduler-working-in-modeline-flag}
@deffn Option semantic-idle-scheduler-working-in-modeline-flag
If non-@code{nil}, show working messages in the mode line.  Normally,
re-parsing shows messages in the minibuffer; this moves the parse
message to the modeline instead.
@end deffn

@anchor{semantic-before-idle-scheduler-reparse-hook}
@defvar semantic-before-idle-scheduler-reparse-hook
This normal hook is run just before the idle scheduler begins
reparsing.  If any hook function throws an error, the value of this
variable is reset to @code{nil}.  This hook is not protected from
lexical errors.
@end defvar

@anchor{semantic-after-idle-scheduler-reparse-hook}
@defvar semantic-after-idle-scheduler-reparse-hook

This normal hook is run after the idle scheduler finishes reparsing.
If any hook throws an error, this variable is reset to @code{nil}.
This hook is not protected from lexical errors.
@end defvar

@node Idle Working Options
@subsection Idle Working Options

In addition to reparsing buffers, the Semantic idle scheduler performs
additional operations, including the following:

@itemize
@item
Creating the include path caches required for symbol lookup.
@item
Create data type caches.
@item
Saving SemanticDB caches to disk.
@item
Speculatively parsing the files in the same directory as the current
buffer.
@end itemize

Because this extra work is quite time-consuming, it is only carried
out after a longer idle delay.  The following features control how the
idle work is performed.

@anchor{semantic-idle-scheduler-work-idle-time}
@deffn Option semantic-idle-scheduler-work-idle-time
The value of this variable is the amount of idle time, in seconds,
before commencing idle work.  The default is 60.
@end deffn

@anchor{semantic-idle-work-parse-neighboring-files-flag}
@deffn Option semantic-idle-work-parse-neighboring-files-flag
If the value of this variable is non-@code{nil}, the Semantic idle
scheduler uses idle work time to parse files in the same directory as
the current buffer.  This improves the accuracy of tag searches and
saves time when visiting those files later, at the cost of doing a lot
of parsing.  The default is @code{t}.
@end deffn

@node Debugging Idle Time Issues
@subsection Debugging Idle Time Issues

If you see an error signalled during idle time, it could be an
indication of a more serious issue elsewhere.  It is not enough to
enable @code{debug-on-error}, because the idle scheduler inhibits the
debugger.  Instead, use the following commands to debug the error:

@deffn Command semantic-debug-idle-function
@anchor{semantic-debug-idle-function}
Run the Semantic idle function with debugging turned on.
@end deffn

@deffn Command semantic-debug-idle-work-function
@anchor{semantic-debug-idle-work-function}
Run the Semantic idle work function with debugging turned on.
@end deffn

@node Idle Summary Mode
@subsection Idle Summary Mode

Semantic Idle Summary mode is a minor mode that displays a short
summary of the symbol at point, such as its function prototype, in the
echo area.  Its functionality is similar to what ElDoc mode provides
for Emacs Lisp (@pxref{Lisp Doc,,,emacs,Emacs manual}).

@anchor{global-semantic-idle-summary-mode}
@anchor{semantic-idle-summary-mode}
@deffn global-semantic-idle-summary-mode &optional arg
This command toggles Semantic Idle Summary mode in all
@semantic{}-enabled buffers.  You can also toggle it via the
@samp{Show Tag Summaries} menu item in the @samp{Development} menu.
@end deffn

When Semantic Idle Summary mode is active, a summary of the tag at
point is displayed in the echo area.  This display takes place during
the idle time, as given by @code{semantic-idle-scheduler-idle-time}
(@pxref{Idle Scheduler}).

You can override the method for getting the current tag to display by
setting @code{idle-summary-current-symbol-info}.

@anchor{semantic-idle-summary-function}
@deffn Option semantic-idle-summary-function
The value of this variable should be a function to call to display tag
information during idle time.  See the variable
@code{semantic-format-tag-functions} for a list of useful functions.
@end deffn

@anchor{semantic-idle-summary-out-of-context-faces}
@defvar semantic-idle-summary-out-of-context-faces
The value of this variable is a list of font-lock faces indicating
useless summary contexts.  These are generally faces used to highlight
comments or strings.  Semantic Idle Summary mode does not display its
usual summary if the text at point has one of these faces.
@end defvar

@node Idle Completions Mode
@subsection Idle Completions Mode

Semantic Idle Completions mode is a minor mode for performing
@dfn{code completions} during idle time.  The completions are
displayed inline, with keybindings that allow you to cycle through
different alternatives.

@c   @xref{Analyzer}, for information about code
@c completion.

@anchor{global-semantic-idle-completions-mode}
@anchor{semantic-idle-completions-mode}
@deffn global-semantic-idle-completions-mode &optional arg
This command toggles Semantic Idle Completions mode in every
@semantic{}-enabled buffer.  You can also toggle it via the @samp{Show
Tag Completions} menu item in the @samp{Development} menu.
@end deffn

If the tag at point has at least one completion, Semantic Idle
Completions mode displays that completion inline---i.e., as part of
the buffer text (you can change the display method by customizing
@code{semantic-complete-inline-analyzer-idle-displayor-class}, as
described below).  The completed part is highlighted, to indicate that
it is not yet properly inserted into the buffer.  The echo area shows
the completion, and whether there are other possible completions, like
this:

@example
besselj [1 of 6 matches]
@end example

@noindent
While the completion is being displayed, the following keybindings
take effect:

@table @kbd
@item @key{RET}
@itemx C-m
Accept the current completion (@code{semantic-complete-inline-done}),
placing it in the buffer and moving point to the end of the completed
tag.
@item M-n
Select the next possible completion
(@code{semantic-complete-inline-down}).  The new completion is shown
inline, replacing the old completion.
@item M-p
Select the previous possible completion
(@code{semantic-complete-inline-up}).
@item @key{TAB}
@item C-i
Accept as much of the completion as possible.  If no additional
completion can be accepted without ambiguity, select the next possible
completion (@code{semantic-complete-inline-TAB}).
@item C-g
Quit without completing (@code{semantic-complete-inline-quit}).
@end table

@noindent
You can also exit inline completion by issuing any other Emacs
command.  The completion text then disappears from the buffer.

@anchor{semantic-complete-analyze-inline-idle}
@deffn Command semantic-complete-analyze-inline-idle
This is the command for performing inline code completion.  It is
called by Semantic Idle Completions mode during idle time, but you can
also call it yourself.  It returns immediately, leaving the buffer in
a state for inline completion.
@end deffn

@anchor{semantic-complete-inline-analyzer-idle-displayor-class}
@deffn Option semantic-complete-inline-analyzer-idle-displayor-class
The value of this variable determines how
@code{semantic-complete-analyze-inline-idle} shows its completions.
Possible values include:

@table @code
@item semantic-displayor-ghost
Display completions ``inline'' with the buffer text, as described
above.  This is the default value.

@item semantic-displayor-tooltip
Display completions in a tooltip.

@item semantic-displayor-traditional
Display completions in a separate window.
@end table
@end deffn
