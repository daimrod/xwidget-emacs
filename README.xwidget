* Xwidgets

This is an experimental branch to enable embedding of GTK widgets
inside an Emacs window. The Emacs abstraction is called an Xwidget,
for eXternal widget, and also in reference to the Xembed protocoll.

There is a demo file called xwidget-test.el which shows some of the
possibilities. There are some screnshots at the emacswiki.

Currently its possible to insert buttons, sliders, and xembed widgets
in the buffer. It works similar to the support for images in Emacs.
Adding more types of widgets should be fairly straightforward, but
will require adapter code for each type.

A difference from images is that xwidgets live their own life. You
create them with an api, get a reference, and tie them to a particular
buffer with a display spec. 

Each xwidget can have several views. In MVC terms, an xwidget is the
model, and an xwidget-view is a view of the xwidget in a particular
Emacs window.

The xwidget code attempts to keep the visual appearance of the views
in sync with through an Observer pattern implementation.

** MVC and Xembedd
The MVC approach appears to be at least in principle robust for plain gtk
widgets. For the interesting case of gtk sockets which implements an
xembed host widget that allows for embedding other applications inside
an Emacs window, the story gets more complex.

The problem is that xembed is designed to plug an application window
inside a a secket and thats it. You can't move a plug between
sockets. I tried numerous hacks to get around this but there is
nothing that works realy well.

Therefore the Emacs part of the code will only expose well-defined
interfaces. cooperating applications will be able to use the interface
in a well defined manner. The problem is that there is no known xembeddable
application that implement the needed type of functionality, which is
allowing for creating new windows on the fly that plug into new
sockets.

Therefore I will attempt to provide an external application that wraps
another application and through hacks attempts to provide the needed
multi view xembed function. That way Emacs is sane and the insanity
contained.

This app will work by providing a socket that an app plugs into. The
socket window is copied efficientlp by means of composition to a
number of other windows, that then are plugged into the different
Emacs sockets. 

* Brief overview of how xwidgets work
Xwidgets work in one way like images in Emacs. You bind a display spec very
similar to an image display spec to buffer contents. The display engine will
notice the display spec and try to display the xwidget there. The display engine
prepares space at the right place for the xwidget and so on for free, as long as
we provide proper sizes and so on back to the redisplay engine.

** Issues
The problem is that Emacs cant actually draw the widgets, as it can with
images. Emacs must notify GTK about where the widgets should be, and how they
should be clipped and so on, and this information must be given to GTK
synchonous with Emacs display changes. Ok, so why is that difficult then?

- How do we know when a widget is NOT to be drawn? The only way I found so far
  is having a flag for each xwdiget, that is reset before a redisplay. When an
  xwidget is encountered during display, the flag is set. After redisplay,
  iterate all xwidgets and hide those which hasnt been displayed. 

- The gtk socket type for embedding external applications is desirable
  but presents a lot of difficulties of its own. One difficulty is
  deciding which input events to forward, and when and how to do it.

** placement and clipping
the entire emacs frame is a gtk window. we use the fixed layout
manager to place xwidgets on the frame. coordinates are supplied by
the emacs display engine. widgets are placed inside an intermediate
window, called the widgetwindow. the widgetwindows are placed on the
emacs frame.

this way was chosen to simplify clipping of the widgets against emacs
window borders.


** different strategies
Integrating toolkit widgets(gtk in this case) and the emacs display
engine is more difficult than your plain average gui application, and
different strategies has been tested and will continue to be tested.

There was a distinction between live xwidgets and
phantom xwidgets, previous to the change to MVC.

- the first aproach was to have the live xwidget on-screen, and move
  them about. the phantoms were generated by snapshoting the live
  xwidget. 

the drawback of that aproach was that the gtk toolkit is admirably
lazy and doesnt draw the widget if its not actualy shown, meaning that
the snapshots for the phantoms will show garbage.

- the second aproach was to use composition support. that tells gtk
  that the widget should be drawn in an off-screen buffer and drawn on
  screen by the application.

this has the primary advantage that the snapshot is always
available, and enables the possibility of more eye-candy like drawing
live and phantom widgets in different colors.

the drawback is that its our own responsibility to handle drawing,
which puts more of the display optimization burden on us.

this is aproach worked so-so.

- another aproach is to have both live and phantom widgets drawn
  on-screen by proxy gtk objects. the live xwidget will be entirely
  handled in an off-screen window, and the proxy objects will redirect
  events there.

- combine on-screen and off-screen aproaches. maybe composition is the
  way to go for most cases, but on-screen xembeding is the way to go
  for particular special cases, like showing video in a
  window. off-screen rendering and whatnot, is not efficient in that
  particular case, and the user will simply have to accept that the
  phantom of a video widget isnt particularily beautiful.

- The current and seemingly sanest aproach implements a MVC pattern.

** Testing
;;test like:
;; cd /path/to/xwidgets-emacs-dir
;; make   all&&  src/emacs -q --eval "(progn (load \"`pwd`/lisp/xwidget-test.el\") (xwidget-demo-basic))"

* ToDo:s

** DONE Examine using XComposite rather than GTK off-screen
  rendering. This would make xembed widgets work much better. This
  would probably be rathter difficult, but could open up other
  interesting possibilities for Emacs. There is an early attempt in
  xwidget.c, but the X call to redirect to offscreen rendering fails
  for unknown reasons.

  the attempt was further worked on, and the xlib calls replaced with
  gdk calls, this works better.

** TODO  make the keyboard event code propagation code work. There is an attempt 
to provide an api to send keyboard events to an xwidget, but it doesnt currently
work very well.

** DONE remove the special-case for when the minibuffer is
  active.  I added some code to reduce the annoying problem display artefacts
  when making the minibuffer the selected window. This made xwidgets in the
  buffer go grey or black whenever one did m-x to activate the minibuffer. The
  coded tried to handle the minibuffer as a special case. That simply wasnt a
  good idea. Special-casing will never work properly. It is much better to spend
  time finding solutions that work acceptably in the general case.

** DONE disable emacs cursor drawing on top of an active xwidget. 
  This ought to be rather simple and should improve the visuals a lot.

** TODO  improve the xwidgets programming interface so its less of
  hand-waving affair. This shouldnt be too hard, but I have deliberatley not
spent any time on it, since getting the visuals right is much
harder. Anyway, I sort of think the interface should be somewhat like
it is, except symbols is used instead of integers.
*** DONE use symbols for xwidget types rather than ints
    CLOSED: [2011-06-27 Mon 12:52]


*** TODO better lisp based structure for xwidgets
the lisp interface woud be like this:
- xwidget-create returns an xwidget object, similar to a process
  object. this id is used when creating the display spec(instead of
  the user defined id now used)

the data structure would be something like this:
- a "process" like aproach to create the xwidgets. xwidgets are
  coupled to buffers, somewhat like processes, except a buffer can
  hold several xwidgets
- an xwidget has a plist to hold the model, like a process
- an xwidget has an assoc list of xwidget views

there are some things that arent clear:
- an xwidget doesnt necessarily need to be coupled to a buffer but it
  seems to be the clearest model. xwidgets would be buffer local
- xwidget-views are by necessity coupled to a emacs window so it might
  be better to store them window locally rather than in an assoc
  coupled to the xwidget model
- for some gtk widgets that resist an mvc approach, like the webkit
  widgets, special operations are needed, similar to the old phantom
  widgets aproach. so we need to differentiate live and phantom
  instances for these troublesome widgets and let lisp manage all the trickery.

stuff that needs to work:
- do something for all views of a xwidget(resize, value change)
- do something for all xw-views in an emacs window(deletion etc)
- lookup xw-view for xwidget in emacs window(during redisplay)
(- do something for all siblings of a xw-view. not atm)

** TODO  more documentation
There should be user docs, and xwidget contributor docs. The current README
is all contributor docs there is now, apart from the code.



** TODO  look into more ways of displaying xwidgets, like binding them to a
window rather than a point in a buffer. This was suggested by Chidong.
This would be a useful addition to Emacs in itself, and would avoid nearly all 
display issues. I still think the general case is more interesting, but this
special case should also be added. The xwidget would then be bound to
replace the view of a particular window, and it would only show in
that window.


** DONE MVC mode for xwidgets
   CLOSED: [2011-06-27 Mon 12:53]
It appears unfruitful to chase using the same display mode for all
types of xwidgets. Composition is fun but not robust the way I'm
tried to do it.

Instead there should be a set of MVC xwidgets. Each on-screen instance
of an MVC widget would be a real GTK widget. The instances would
communciate state using signals. 

There are drawbacks. There is no inbuilt support for MVC in GTK, so we
have to roll our own, which is tedious if not much work for the few
cases.

MVC for xembedded application will need support from the applications
themselves. Inkscape supports multiple views to the same document,
other programs don't. In practice it might not be a big drawback.


*** DONE figure out what to do with the multiple frames case. 
    CLOSED: [2011-06-27 Mon 12:52]
This should be easier to solve with MVC.
Surprisingly, this just worked!
*** DONE how to propagate changes in views to other views?
    CLOSED: [2011-06-27 Mon 12:53]
I used gtk signals, the implementation for sliders works well!

** TODO canvas support
heresy an interesting comparision of gtk canvases
http://live.gnome.org/ProjectRidley/CanvasOverview
*** goocanvas
goocanvas is a gtk canvas implemented using cairo. investigate.

pros:
- it has a MVC model aproach out of the box which is nice.

http://developer.gnome.org/goocanvas/unstable/goocanvas-model-view-canvas.html

export CFLAGS="`pkg-config --cflags goocanvas` -DHAVE_GOOCANVAS"
export LDFLAGS=`pkg-config --libs goocanvas`
./configure
make

I made a hello goo world xwidget so seems doable.
I wanted to load a SVG which wasnt immediately straightforward, so I
tried clutter. but it turns out the exact same strategy could be used
with goocanvas.

*** clutter
maybe clutter can be used as a canvas? 
pros:
- seems to have a lot of traction atm. many examples
- potentialy fast and cool vector graphics
cons:
- no out of the box MVC support, but seems doable. no worse than the
  other home brew mvc support I have in xwidgets
(media-explorer in an application that employes the MVC pattern)

http://www.openismus.com/documents/clutter_tutorial/0.9/docs/tutorial/html/sec-stage-widget.html

there is also cool stuff like this:
http://gitorious.org/webkit-clutter/webkit-clutter which is an webkit actor for
clutter! hmmmmm.

I want to render svg. aparently:
  librsvg rsvg_handle_render_cairo(h, cr);
  ClutterCairoTexture
  Clutter

export CFLAGS="`pkg-config --cflags clutter-gtk-1.0` -DHAVE_CLUTTER"
export LDFLAGS=`pkg-config --libs clutter-gtk-1.0`
./configure
make

compiles but I get:
Gtk-ERROR **: GTK+ 2.x symbols detected. Using GTK+ 2.x and GTK+ 3 in
the same process is not supported

export CFLAGS="`pkg-config --cflags clutter-gtk-0.10` -DHAVE_CLUTTER"
export LDFLAGS=`pkg-config --libs clutter-gtk-0.10`
./configure
make


** TODO mvc code crashes after a while
seemingly only when compiling with optimizations

** TODO delete xwidgets belonging to an emacs window
when it closes
** TODO xwidget-resize-at
currently it rewrites the display spec. then it resizes the xwidget
views. maybe rewriting the spec should be sufficient, and changes to
it be picked up during redisplay somehow.

** TODO display spec validation
it is an error to reuse xwidgets in several buffers or in the same
buffer. how do we catch these errors?


** TODO browser xwidget
although embedding a browser is not my primary concern many are
interested in this. some suitable browser component needs to be found
supporting gtk.

*** webkit
there is a webkit gtk port. there is no obvious mvc support.
http://live.gnome.org/WebKitGtk
http://webkitgtk.org/

it might be possible to keep a set of webxits in artificial
synchronisation by recursive deep copy of the DOM from one webkit to
another. This will be error prone at best though. Another way might be
to just use bitmap copy of the "live"instance to the "phantom"
instances. the problem of transfering the live view remains though.

export CFLAGS="`pkg-config --cflags webkit-1.0` -DHAVE_WEBKIT -g"
export LDFLAGS=`pkg-config --libs webkit-1.0`
./configure
make

export CFLAGS="`pkg-config --cflags webkit-1.0` -DHAVE_WEBKIT_OSR -g"
export LDFLAGS=`pkg-config --libs webkit-1.0`
./configure
make



*** firefox
http://www-archive.mozilla.org/unix/gtk-embedding.html
seems to be severly bitrotted
